from sentence_transformers import SentenceTransformer
import pandas as pd
import json
import faiss
import os
from tqdm import tqdm
import numpy as np
from utils.version_checker import is_version_vulnerable
from utils.cve_mapping import download_csv, load_edb_cve_mapping

EXPLOITDB_PATH = ".\\data\\exploitdb_descriptions.json"
EXPLOITDB_INDEX_PATH = ".\\data\\exploitdb.index"
EXPLOITDB_META_PATH = ".\\data\\exploitdb.meta.json"
EXPLOITDB_CSV_URL = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
# ------------- RAG SUMMARIZER (EXPLOITDB) -------------
class ExploitDBRAG:
    def __init__(self, path=EXPLOITDB_PATH, force_download=False):
        self.cve_to_poc = {}
        self.model = SentenceTransformer("all-MiniLM-L6-v2")
        self.index = None
        self.texts = []
        self.links = []

        if force_download or not os.path.exists(path):
            self.scrape_exploitdb(path)
            self.load_exploits(path)
            self.build_cve_to_poc()
            self.save_to_cache()

        if os.path.exists(EXPLOITDB_INDEX_PATH) and os.path.exists(EXPLOITDB_META_PATH):
            self.load_from_cache()
            self.build_cve_to_poc()  
        else:
            self.load_exploits(path)
            self.save_to_cache()
            self.build_cve_to_poc()  

    def scrape_exploitdb(self, output_path):
        print("[*] Scraping ExploitDB...")
        title_col = "title"         # üîÅ Update if needed
        desc_col = "description"    # üîÅ Update if needed
        # Download and load EDB‚ÜíCVE map
        csv_path = download_csv(os.path.dirname(output_path))
        df = pd.read_csv(csv_path, encoding="utf-8", low_memory=False)
        edb_to_cves = load_edb_cve_mapping(csv_path)

        self.links = []
        combined_texts = []
        self.poc_downloads = []

        for _, row in df.iterrows():
            eid = str(row["id"]).strip()
            title = str(row.get(title_col, "")).strip()
            desc = str(row.get(desc_col, "")).strip()
            text = f"{title} - {desc}"
            link = f"https://www.exploit-db.com/exploits/{eid}"
            poc_download_link = f"https://www.exploit-db.com/download/{eid}"

            combined_texts.append(text)
            self.links.append(link)
            self.poc_downloads.append(poc_download_link)

            for cve_id in edb_to_cves.get(eid, []):
                self.cve_to_poc.setdefault(cve_id.upper(), []).append(link)

        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump({"texts": combined_texts, "links": self.links}, f, indent=2)
        print(f"[+] Saved {len(combined_texts)} exploit entries to {output_path}.")
        for cve_id in edb_to_cves.get(eid, []):
            self.cve_to_poc.setdefault(cve_id.upper(), []).append(link)
            print(f"Mapped {cve_id.upper()} ‚Üí {link}")

    def load_exploits(self, path):
        print("[*] Loading ExploitDB descriptions...")
        with open(path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            self.texts = data.get("texts", [])
            self.links = data.get("links", [""] * len(self.texts))

        print("[*] Generating embeddings...")
        embeddings = [self.model.encode(text, convert_to_tensor=False) for text in tqdm(self.texts, desc="Embedding ExploitDB entries", unit="entry")]

        self.index = faiss.IndexFlatL2(len(embeddings[0]))
        self.index.add(np.array(embeddings))
        print(f"[+] Loaded and indexed {len(self.texts)} exploit descriptions.")

    def save_to_cache(self):
        faiss.write_index(self.index, EXPLOITDB_INDEX_PATH)
        with open(EXPLOITDB_META_PATH, 'w') as f:
            json.dump({"texts": self.texts, "links": self.links, "cve_to_poc": self.cve_to_poc}, f)

    def load_from_cache(self):
        print("[*] Loading cached ExploitDB index...")
        self.index = faiss.read_index(EXPLOITDB_INDEX_PATH)
        with open(EXPLOITDB_META_PATH, 'r') as f:
            data = json.load(f)
            self.texts = data.get("texts", [])
            self.links = data.get("links", [])
            self.cve_to_poc = data.get("cve_to_poc", {})

    def summarize(self, query, top_k=1):
        vec = self.model.encode([query])[0]
        D, I = self.index.search(np.array([vec]), top_k)
        return [(self.texts[i][:300], self.links[i]) for i in I[0]]

    def get_link_for_cve(self, cve_id):
        links = self.cve_to_poc.get(cve_id)
        return links[0] if links else None
    
    def get_pocs_for_cve(self, cve_id):
    # Return list of PoC URLs for the given CVE or empty list
            return self.cve_to_poc.get(cve_id.upper(), [])
    
    def build_cve_to_poc(self):
        csv_filepath = os.path.join(os.getcwd(), "utils")
        csv_path = download_csv(csv_filepath)
        edb_to_cves = load_edb_cve_mapping(csv_path)

        self.cve_to_poc = {}
        for eid, cves in edb_to_cves.items():
            link = f"https://www.exploit-db.com/exploits/{eid}"
            download_link = f"https://www.exploit-db.com/download/{eid}"
            for cve_id in cves:
                self.cve_to_poc.setdefault(cve_id.upper(), []).append(link)
                self.cve_to_poc.setdefault(cve_id.upper(), []).append(download_link)
        print(f"[+] Mapped {len(self.cve_to_poc)} CVEs to PoC links.")

def match_services_to_cves(services, cves):
    matches = []
    for svc in services:
        ip = svc["ip"]
        port = svc["port"]
        product = svc["product"]
        detected_version = svc["version"]
        for cve in cves:
            for affected in cve["affected"]:
                # Match product and vendor loosely (could be improved)
                if affected["product"].lower() in product or product in affected["product"].lower():
                    if is_version_vulnerable(detected_version, affected):
                        matches.append({
                            "ip": ip,
                            "port": port,
                            "product": product,
                            "version": detected_version,
                            "cve_id": cve["cve_id"],
                            "description": cve["description"],
                        })
    return matches
